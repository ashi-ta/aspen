#!/usr/bin/env python3
# encoding: utf-8
"""Colored noise"""

from logging import getLogger
from typing import List, Sequence

import numpy as np

from aspen.interfaces.abs_common_interface import AbsCommonInterface
from aspen.interfaces.abs_sound_interface import AbsSoundInterface
from aspen.processings.declip import declip
from aspen.processings.normalize import normalize

logger = getLogger(__name__)


class ColoredNoise(AbsCommonInterface, AbsSoundInterface):
    """Generate colored noise.
    Colored noise is generated according to the following table.

    ======  ============  ====================  ==================================
    Color   Power/octave  Power density/octave  Inverse value of frequency scaling
    ======  ============  ====================  ==================================
    White   +3 dB         0 dB                  0
    Pink    0 dB          -3 dB                 1 (i.e. 1 / f)
    Blue    +6 dB         +3 dB                 -1 (i.e. f)
    Brown   -3 dB         -6 dB                 2 (i.e. 1 / f^2)
    Violet  +9 dB         +6 dB                 -2 (i.e. f^2)
    ======  ============  ====================  ==================================

    Args:
        colored_noise_duration: The duration of colored noise in millisecond.
            Defaults to [1000].
        colored_noise_color: The type of colored noise.
            The choices are `white`, `pink`, `blue`, `brown` and `violet`.
            Defaults to ["white"].
        colored_noise_num_signals: Number of signals.
            If this value greater than 2, the other arguments should contain 2 types.
            Defaults to 1.
        samp_freq: Sampling frequency. Defaults to 16000.
    """

    def __init__(
        self,
        colored_noise_duration: Sequence[float] = [1000],
        colored_noise_color: Sequence[str] = ["white"],
        colored_noise_num_signals: int = 1,
        samp_freq: int = 16000,
    ):
        self.duration = colored_noise_duration
        self.color = colored_noise_color
        self.num_signals = colored_noise_num_signals
        self.samp_freq = samp_freq

    @staticmethod
    def add_arguments(parser):
        group = parser.add_argument_group("Colored noise setting")
        group.add_argument(
            "--colored-noise-duration",
            type=float,
            default=[1000],
            nargs="*",
            help="Duration of colored noise in millisecond",
        )
        group.add_argument(
            "--colored-noise-color",
            type=str,
            default=["white"],
            nargs="*",
            choices=[
                "white",
                "brown",
                "pink",
                "blue",
                "violet",
            ],
            help="Type of colored noise",
        )
        group.add_argument(
            "--colored-noise-num-signals",
            type=int,
            default=1,
            help="Number of signals. If this value greater than 2,"
            "the other arguments should contain 2 types.",
        )
        return parser

    def _generate_each(self, idx: int) -> np.ndarray:
        duration = int(self.duration[idx] * self.samp_freq / 1000)
        color = self.color[idx]
        if color == "white":
            inv_freq_scale = 0
        elif color == "pink":
            inv_freq_scale = 1
        elif color == "blue":
            inv_freq_scale = -1
        elif color == "brown":
            inv_freq_scale = 2
        elif color == "violet":
            inv_freq_scale = -2
        else:
            raise ValueError("Invalid color, got {}".format(color))

        x = np.random.normal(loc=0, scale=1, size=[duration]).astype(np.float64)
        X = np.fft.rfft(x, norm="forward")
        # power spectrum is calculated by abs(spectrum)**2
        # however, the below scaling is implemented under spectrum scale.
        # (e.g. pink noise is generated by 1/f scale of power spectrum theoretically,
        # therefore, scaling factor in spectrum is defined by (1/(f**(1/2)))
        scaling = np.arange(1, X.shape[0] + 1) ** (inv_freq_scale / 2)
        y = np.fft.irfft(X / scaling, norm="forward").real[:duration]
        # ensure unity standard deviation and zero mean value
        y = declip(normalize(y, "zscore"), 1.0)
        return y


def colored_noise(
    duration: Sequence[float] = [1000],
    color: Sequence[str] = ["white"],
    num_signals: int = 1,
    samp_freq: int = 16000,
) -> List[np.ndarray]:
    """Generate colored noise.
    Colored noise is generated according to the following table.

    ======  ============  ====================  ==================================
    Color   Power/octave  Power density/octave  Inverse value of frequency scaling
    ======  ============  ====================  ==================================
    White   +3 dB         0 dB                  0
    Pink    0 dB          -3 dB                 1 (i.e. 1 / f)
    Blue    +6 dB         +3 dB                 -1 (i.e. f)
    Brown   -3 dB         -6 dB                 2 (i.e. 1 / f^2)
    Violet  +9 dB         +6 dB                 -2 (i.e. f^2)
    ======  ============  ====================  ==================================

    Args:
        duration: The duration of colored noise in millisecond.
            Defaults to [1000].
        color: The type of colored noise.
            The choices are `white`, `pink`, `blue`, `brown` and `violet`.
            Defaults to ["white"].
        num_signals: Number of signals.
            If this value greater than 2, the other arguments should contain 2 types.
            Defaults to 1.
        samp_freq: Sampling frequency. Defaults to 16000.

    Returns:
        Output signals.
    """
    return ColoredNoise(duration, color, num_signals, samp_freq)()
